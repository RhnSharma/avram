require "./database_validations"
require "./inherit_column_attributes"

abstract class Avram::SaveOperation(T) < Avram::Operation
  include Avram::DatabaseValidations
  include Avram::InheritColumnAttributes

  macro inherited
    @valid : Bool = true
    @@permitted_param_keys = [] of String
    @@schema_class = T
  end

  @record : T? = nil
  getter :record

  abstract def table_name
  abstract def attributes
  abstract def primary_key_name
  abstract def database

  def self.param_key
    T.name.underscore
  end

  def run

  end

  def changes : Hash(Symbol, String?)
    _changes = {} of Symbol => String?
    column_attributes.each do |attribute|
      if attribute.changed?
        _changes[attribute.name] = cast_value(attribute.value)
      end
    end
    _changes
  end

  # Permit these columns from your model to be assign a value from params.
  # 
  # ```
  # class SaveUser < Avram::SaveOperation
  #   permit_columns :name, :email, :phone_number
  # end
  # ```
  macro permit_columns(*attribute_names)
    {% for attribute_name in attribute_names %}
      {% if attribute_name.is_a?(TypeDeclaration) %}
        {% raise <<-ERROR
          Must use a Symbol or a bare word in 'permit_columns'. Instead, got: #{attribute_name}

          Try this...

            ▸ permit_columns #{attribute_name.var}

          ERROR
        %}
      {% end %}
      {% unless attribute_name.is_a?(SymbolLiteral) || attribute_name.is_a?(Call) %}
        {% raise <<-ERROR
          Must use a Symbol or a bare word in 'permit_columns'. Instead, got: #{attribute_name}

          Try this...

            ▸ Use a bare word (recommended): 'permit_columns name'
            ▸ Use a Symbol: 'permit_columns :name'

          ERROR
        %}
      {% end %}
      {% if COLUMN_ATTRIBUTES.any? { |attribute| attribute[:name].id == attribute_name.id } %}
        def {{ attribute_name.id }}
          _{{ attribute_name.id }}.permitted
        end

        @@permitted_param_keys << "{{ attribute_name.id }}"
      {% else %}
        {% raise <<-ERROR
          Can't permit '#{attribute_name}' because the column has not been defined on the model.

          Try this...

            ▸ Make sure you spelled the column correctly.
            ▸ Add the column to the model if it doesn't exist.
            ▸ Use 'attribute' if you want an attribute that is not saved to the database.

          ERROR
        %}
      {% end %}
    {% end %}
  end

  # :nodoc:
  macro add_column_attributes(attributes)
    {% for attribute in attributes %}
      {% COLUMN_ATTRIBUTES << attribute %}
      @_{{ attribute[:name] }} : Avram::Attribute({{ attribute[:type] }}?)?

      def {{ attribute[:name] }}
        _{{ attribute[:name] }}
      end

      def {{ attribute[:name] }}=(_value)
        \{% raise <<-ERROR
          Can't set an attribute value with '{{attribute[:name]}} = '
          Try this...
            ▸ Use '.value' to set the value: '{{attribute[:name]}}.value = '
          ERROR
          %}
      end

      private def _{{ attribute[:name] }}
        @_{{ attribute[:name] }} ||= Avram::Attribute({{ attribute[:type] }}?).new(
          name: :{{ attribute[:name].id }},
          param: permitted_params["{{ attribute[:name] }}"]?,
          value: @record.try(&.{{ attribute[:name] }}),
          param_key: self.class.param_key)
      end

      def permitted_params
        new_params = {} of String => String
        @params.nested(self.class.param_key).each do |key, value|
          new_params[key] = value
        end
        new_params.select(@@permitted_param_keys)
      end

      def set_{{ attribute[:name] }}_from_param(_value)
        {% if attribute[:type].is_a?(Generic) %}
          # Pass `_value` in as an Array. Currently only single values are supported.
          # TODO: Update this once Lucky params support Arrays natively
          parse_result = {{ attribute[:type].type_vars.first }}::Lucky.parse([_value])
        {% else %}
          parse_result = {{ attribute[:type] }}::Lucky.parse(_value)
        {% end %}
        if parse_result.is_a? Avram::Type::SuccessfulCast
          {{ attribute[:name] }}.value = parse_result.value.as({{ attribute[:type] }})
        else
          {{ attribute[:name] }}.add_error "is invalid"
        end
      end
    {% end %}

    private def extract_changes_from_params
      permitted_params.each do |key, value|
        {% for attribute in attributes %}
          set_{{ attribute[:name] }}_from_param value if key == {{ attribute[:name].stringify }}
        {% end %}
      end
    end

    def attributes
      column_attributes + super
    end

    private def column_attributes
      [
        {% for attribute in attributes %}
          {{ attribute[:name] }},
        {% end %}
      ]
    end

    def required_attributes
      Tuple.new(
        {% for attribute in attributes %}
          {% if !attribute[:nilable] && !attribute[:autogenerated] %}
            {{ attribute[:name] }},
          {% end %}
        {% end %}
      )
    end
  end

  # :nodoc:
  macro add_cast_value_methods(columns)
    private def cast_value(value : Nil)
      nil
    end

    {% for column in columns %}
    # pass `value` to it's `Lucky.to_db` for parsing.
    # In most cases, that's just calling `to_s`, but in the case of an Array,
    # `value` is passed to `PQ::Param` to properly encode `[true]` to `{t}`, etc...
    private def cast_value(value : {{ column[:type] }})
      value.not_nil!.class.adapter.to_db(value.as({{ column[:type] }}))
    end
    {% end %}
  end
end
